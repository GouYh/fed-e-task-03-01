# fed-e-task-03-01
## 一、简答题
   1.当我们点击按钮的时候动态给data增加的成员是否是响应式数据，如果不是的话，如何把新增成员设置成响应式数据，它的内部原理是什么。
    let vm = new Vue({
        el: '#el,
        data: {
            o: 'object',
            dog: {}
        },
        methods: {
            clickHandler () {
                // 该name属性是否是响应式的
                this.dog.name = 'Trump'
            }
        }
    })

    答：this.dog.name不是响应式数据，因为在设置对象属性的时候，不会触发setter，重新对name属性进行defineProperty数据劫持。
        可以通过Vue.set方法或者this.$set方法设置对象的属性，将新增成员设置成响应式数据，内部原理是Vue内部实现了set方法，在设置对象属性的时候，使用defineProperty对新增的属性进行数据劫持，从而实现响应式。

   2.请简述Diff算法的执行过程
    
    答：Diff算法的核心就是updateChildren，对比新旧节点的children，更新DOM，其执行过程如下：
        要对比两颗树的差异，我们可以取第一棵树的每一个节点依次和第二棵树的每一个节点比较，但是这样时间复杂度为O(n^3)，
        在DOM操作的实时我们很少会出现跨层级的移动，
        因此只需要找同级别的子节点依次比较，然后再招下一级别的节点比较，这样算法的时间复杂度为O(n)，
        在进行同级别节点比较的时候，首先会对新老节点数组的开始和结尾节点设置标记索引，遍历过程中移动索引，
        在对开始和结束节点比较的时候，总共有四种情况，即开始节点和结束节点的两两对比。
        如果以上四种情况都不满足，则遍历新节点，使用新开始节点的key在老节点数组中找相同节点，
        如果没有找到，说明新开始节点是新节点，
        如果找到了，判断是否相同，如果不相同，则重新创建DOM元素，插入到DOM中，如果相同，移动元素，
        同层级对比完毕之后，
        如果老节点数组先遍历完，需要对新节点剩余节点批量插入右边，
        如果新节点数组先遍历完，把老节点数组剩余节点批量删除。


## 二、编程题

    1.模拟VueRouter的hash模式的实现，实现思路和History模式类似，把URL中的#后面的内容作为路由的地址，可以通过hashchange事件监听路由地址的变化。

    答：见code/vuerouter

    2.在模拟Vue.js响应式源码的基础上实现v-html指令，以及v-on指令。

    答：见code/minivue

    3.参考Snabbdom提供的电影列表的示例，利用Snabbdom实现类似的效果，如图：

    答：见code/snabbdom
